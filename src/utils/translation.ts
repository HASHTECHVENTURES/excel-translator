import { Cell, TranslationSettings, GlossaryTerm } from '../types';
import { PromptTemplate } from '../components/PromptEditor';

const GEMINI_API_KEY = 'AIzaSyD_H_MSp1zjV3PFJo4cYIQZLIczD8ROPsA';
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';

export const translateCells = async (
  cells: Cell[],
  settings: TranslationSettings,
  glossary: GlossaryTerm[],
  onProgress?: (progress: number) => void,
  customPrompt?: PromptTemplate
): Promise<Cell[]> => {
  const cellsToTranslate = cells.filter(cell => 
    cell.v && (typeof cell.v === 'string' || typeof cell.v === 'number') && !cell.skip
  );
  
  if (cellsToTranslate.length === 0) {
    return cells;
  }
  
  const batchSize = 50; // Process in batches to avoid API limits
  const translatedCells = [...cells];
  
  // Keep track of which cells have been translated
  let translatedCount = 0;
  
  for (let i = 0; i < cellsToTranslate.length; i += batchSize) {
    const batch = cellsToTranslate.slice(i, i + batchSize);
    const texts = batch.map(cell => cell.v.toString());
    
    try {
      console.log(`ЁЯФД Processing batch ${Math.floor(i / batchSize) + 1}, cells ${i + 1}-${Math.min(i + batchSize, cellsToTranslate.length)}`);
      
      const translations = await translateBatch(texts, settings, glossary, customPrompt);
      
      console.log(`ЁЯУК Batch ${Math.floor(i / batchSize) + 1} results:`, {
        textsSent: texts.length,
        translationsReceived: translations.length,
        translationsWithContent: translations.filter(t => t && t.trim()).length
      });
        
      // Update the translated cells for this batch only
      batch.forEach((batchCell, batchIndex) => {
        if (batchIndex < translations.length) {
          const translation = translations[batchIndex];
          // If translation is empty or undefined, use original text
          const finalTranslation = translation && translation.trim() ? translation : batchCell.v.toString();
          
          // Find the cell in the original array and update it
          const cellIndex = translatedCells.findIndex(cell => 
            cell === batchCell || 
            (cell.v === batchCell.v && cell.row === batchCell.row && cell.col === batchCell.col)
          );
          
          if (cellIndex !== -1) {
            translatedCells[cellIndex] = {
              ...batchCell,
              translated: finalTranslation
            };
            translatedCount++;
            
            // Debug: Log successful translation
            translatedCount++;
          }
        }
      });
      
      console.log(`тЬЕ Batch ${Math.floor(i / batchSize) + 1} completed. Total cells translated so far: ${translatedCount}`);
      
      // Update progress
      if (onProgress) {
        const progress = Math.min((i + batchSize) / cellsToTranslate.length, 1);
        onProgress(progress);
      }
      
      // Add a small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
      
    } catch (error) {
      console.error('Translation batch failed:', error);
      // Continue with next batch
    }
  }
  
  return translatedCells;
};

const translateBatch = async (
  texts: string[],
  settings: TranslationSettings,
  glossary: GlossaryTerm[],
  customPrompt?: PromptTemplate
): Promise<string[]> => {
  const systemPrompt = customPrompt ? customPrompt.systemPrompt : generateSystemPrompt(settings, glossary);
  const userPrompt = customPrompt ? customPrompt.userPrompt.replace('{texts}', texts.map((text, index) => `${index + 1}. ${text}`).join('\n')) : generateUserPrompt(texts);
  
  // Log which prompt template is being used
  if (customPrompt) {
    console.log('ЁЯОп Using custom prompt template:', customPrompt.name);
    console.log('ЁЯУЭ Custom system prompt length:', systemPrompt.length, 'characters');
    console.log('ЁЯУЭ Custom user prompt length:', userPrompt.length, 'characters');
  } else {
    console.log('ЁЯОп Using default prompt template');
  }
  
  const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      contents: [
        {
          parts: [
            { text: systemPrompt },
            { text: userPrompt }
          ]
        }
      ],
      generationConfig: {
        temperature: 0.1,
        maxOutputTokens: 8192,
      }
    })
  });
  
  if (!response.ok) {
    throw new Error(`Translation API error: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
    throw new Error('Invalid response from translation API');
  }
  
  const translatedText = data.candidates[0].content.parts[0].text;
  
  console.log('ЁЯОп Raw API response:', translatedText);
  
  // Parse the response back into individual translations
  const translations = parseTranslationResponse(translatedText, texts.length);
  
  console.log('ЁЯУЭ Parsed translations:', translations);
  
  // Post-process translations to fix common issues
  const processedTranslations = postProcessTranslations(translations, texts);
  
  console.log('ЁЯФз Post-processed translations:', processedTranslations);
  
  return processedTranslations;
};

const generateSystemPrompt = (settings: TranslationSettings, glossary: GlossaryTerm[]): string => {
  const languageMap = {
    'hi-IN': 'Hindi',
    'mr-IN': 'Marathi'
  };

  // Language-specific quality rules
  const languageQualityRules = settings.target === 'hi-IN' ? `
HINDI TRANSLATION QUALITY RULES (MANDATORY):

1. TONE AND REGISTER:
- Use colloquial, student-friendly Hindi over overly formal or Sanskritised phrases
- Avoid bureaucratic vocabulary unless contextually required
- Use second-person respectful singular (рдЖрдк, рдХреАрдЬрд┐рдП) consistently for professional but friendly tone

2. FORMAL WORDS TO REPLACE:
- рдФрдкрдЪрд╛рд░рд┐рдХ тЖТ рдЬрд╝рд░реВрд░реА / рд╕рд░рдХрд╛рд░реА
- рдкреНрд░рд╕реНрддрд╛рд╡ тЖТ рдпреЛрдЬрдирд╛
- рд╕реНрдкрд╖реНрдЯрддрд╛ тЖТ рд╕рд╛рдлрд╝ рд╕рдордЭ
- рдкреНрд░рд╢рд┐рдХреНрд╖рдг тЖТ рд╕реАрдЦрдиреЗ рдХреА рдкрд╣рд▓
- рдкреНрд░рдХреНрд░рд┐рдпрд╛ тЖТ рддрд░реАрдХрд╛
- рд╕рдВрджрд░реНрдн тЖТ рд╕рд╛рде / рд╕реНрдерд┐рддрд┐ рдХреЗ рдЕрдиреБрд╕рд╛рд░
- рд╡рд┐рд╢реНрд▓реЗрд╖рдг тЖТ рдЬрд╛рдВрдЪ / рд╕рдордЭ
- рд╕реБрд▓рдн тЖТ рдЖрд╕рд╛рди / рд╕рд░рд▓
- рд╕реНрдерд╛рдкрд┐рдд тЖТ рдордЬрд╝рдмреВрдд рдХрд░рдирд╛ / рдмрдирд╛рдирд╛
- рд╕рд╣рднрд╛рдЧрд┐рддрд╛ тЖТ рднрд╛рдЧреАрджрд╛рд░реА / рд╣рд┐рд╕реНрд╕рд╛ рд▓реЗрдирд╛

3. STRUCTURE & FORMAT:
- Ensure row-wise alignment between English and Hindi
- Use consistent column mappings: "Question" тЖТ "рдкреНрд░рд╢реНрди", "Option1" тЖТ "рд╡рд┐рдХрд▓реНрдк 1", "Correct ans" тЖТ "рд╕рд╣реА рдЙрддреНрддрд░"
- NEVER add serial numbers to column headers - translate them exactly as specified
- Strip serial numbers or prefix numerals from analysis for content cells only

4. LITERAL TRANSLATION CHECKS:
- Avoid calque translations (literal word-for-word copying of English structure)
- Use natural Hindi idioms where appropriate
- Simplify English-origin phrases like "рд╕рдордп рдкреНрд░рдмрдВрдзрди"

5. GRAMMAR CONSISTENCY:
- Ensure gender agreement and postposition accuracy
- Maintain consistent honorific usage
- Avoid mixing pronouns (don't switch between рдЖрдк and рддреБрдо)

6. CULTURAL & CONTEXTUAL ADAPTATION:
- Use terms familiar to Indian classrooms for educational content
- Use Indian names and scenarios in examples when applicable
` : settings.target === 'mr-IN' ? `
MARATHI TRANSLATION QUALITY RULES (MANDATORY):

1. TONE AND REGISTER:
- Use colloquial, student-friendly Marathi over overly formal or Sanskritised phrases
- Avoid bureaucratic vocabulary unless contextually required
- Use respectful tone appropriate for educational content

2. FORMAL WORDS TO REPLACE:
- рдФрдкрдЪрд╛рд░рд┐рдХ тЖТ рдЖрд╡рд╢реНрдпрдХ / рд╕рд░рдХрд╛рд░реА
- рдкреНрд░рд╕реНрддрд╛рд╡ тЖТ рдпреЛрдЬрдирд╛
- рд╕реНрдкрд╖реНрдЯрддрд╛ тЖТ рд╕реНрдкрд╖реНрдЯ рд╕рдордЬ
- рдкреНрд░рд╢рд┐рдХреНрд╖рдг тЖТ рд╢рд┐рдХрдгреНрдпрд╛рдЪреА рд╕реБрд░реБрд╡рд╛рдд
- рдкреНрд░рдХреНрд░рд┐рдпрд╛ тЖТ рдкрджреНрдзрдд
- рд╕рдВрджрд░реНрдн тЖТ рд╕реНрдерд┐рддреА / рдкрд░рд┐рд╕реНрдерд┐рддреАрдиреБрд╕рд╛рд░
- рд╡рд┐рд╢реНрд▓реЗрд╖рдг тЖТ рддрдкрд╛рд╕рдгреА / рд╕рдордЬ
- рд╕реБрд▓рдн тЖТ рд╕реЛрдкреЗ / рд╕рд░рд│
- рд╕реНрдерд╛рдкрд┐рдд тЖТ рдордЬрдмреВрдд рдХрд░рдгреЗ / рддрдпрд╛рд░ рдХрд░рдгреЗ
- рд╕рд╣рднрд╛рдЧрд┐рддрд╛ тЖТ рд╕рд╣рднрд╛рдЧ / рднрд╛рдЧ рдШреЗрдгреЗ

3. STRUCTURE & FORMAT:
- Ensure row-wise alignment between English and Marathi
- Use consistent column mappings: "Question" тЖТ "рдкреНрд░рд╢реНрди", "Option1" тЖТ "рдкрд░реНрдпрд╛рдп 1", "Correct ans" тЖТ "рдпреЛрдЧреНрдп рдЙрддреНрддрд░"
- NEVER add serial numbers to column headers - translate them exactly as specified
- Strip serial numbers or prefix numerals from analysis for content cells only

4. LITERAL TRANSLATION CHECKS:
- Avoid calque translations (literal word-for-word copying of English structure)
- Use natural Marathi idioms where appropriate
- Simplify English-origin phrases

5. GRAMMAR CONSISTENCY:
- Ensure proper Marathi grammar and sentence structure
- Maintain consistent tone and register
- Use appropriate Marathi vocabulary

6. CULTURAL & CONTEXTUAL ADAPTATION:
- Use terms familiar to Indian classrooms for educational content
- Use Indian names and scenarios in examples when applicable
` : '';

  // Domain-specific rules
  const domainRules = settings.domain === 'education' ? `
EDUCATIONAL CONTEXT RULES:
- Use student-friendly, accessible language
- Prefer simple, clear explanations over complex terminology
- Use examples and analogies familiar to Indian students
- Maintain academic rigor while being approachable
` : settings.domain === 'admin' ? `
ADMINISTRATIVE CONTEXT RULES:
- Use professional language appropriate for administrative documents
- Maintain administrative terminology where contextually appropriate
- Use respectful tone throughout
- Preserve technical terms and industry-specific vocabulary
` : '';

  return `You are a professional translator for Indian languages. Translate the provided Excel cell texts into ${languageMap[settings.target]}.

MANDATORY NUMBER TRANSLATION RULES:
- ALWAYS convert ALL Arabic numerals (0-9) to ${languageMap[settings.target]} numerals
- 0тЖТреж, 1тЖТрез, 2тЖТреи, 3тЖТрей, 4тЖТрек, 5тЖТрел, 6тЖТрем, 7тЖТрен, 8тЖТрео, 9тЖТреп
- This includes standalone numbers, numbers in text, and any numeric content
- NEVER leave Arabic numerals untranslated

CRITICAL RULES:
- NEVER change meaning or context
- Preserve placeholders, dates, codes, emails, URLs, formulas exactly as they appear
- For each input cell, return exactly one translated string in the same order
- Use natural, locale-accurate phrasing and idioms
- Maintain professional tone and accuracy
- Preserve any special formatting indicators or placeholders
- Translate ALL text content, including technical terms, proper nouns, and compound words
- Be consistent with terminology throughout the translation
- If a term appears multiple times, translate it consistently
- For educational content, use appropriate academic terminology
- Ensure complete translation - do not leave any English text untranslated

${languageQualityRules}
${domainRules}

Return only the translated strings, one per line, in the exact same order as input.`;
};

const generateUserPrompt = (texts: string[]): string => {
  return `Translate these Excel cell contents into Hindi. Translate ALL text content completely:

${texts.map((text, index) => `${index + 1}. ${text}`).join('\n')}

CRITICAL REQUIREMENTS: 
- Translate every word and phrase completely
- Do not leave any English text untranslated
- ALWAYS convert ALL numbers to Hindi numerals (0тЖТреж, 1тЖТрез, 2тЖТреи, 3тЖТрей, 4тЖТрек, 5тЖТрел, 6тЖТрем, 7тЖТрен, 8тЖТрео, 9тЖТреп)
- Be consistent with terminology
- Provide complete Hindi translations
- Use colloquial, student-friendly Hindi for educational content
- Avoid overly formal or bureaucratic language
- For column headers (Question, Option1, Option2, etc.), translate exactly without adding serial numbers

Provide translations in the same order, one per line:`;
};

const parseTranslationResponse = (response: string, expectedCount: number): string[] => {
  console.log(`ЁЯФН Raw response length: ${response.length}, expected: ${expectedCount}`);
  
  // Split by lines and clean up
  const lines = response
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0);
  
  console.log(`ЁЯФН Found ${lines.length} non-empty lines`);
  
  // Extract translations by removing numbering
  const translations = lines
    .map(line => {
      // Remove numbering like "1. ", "2. " etc.
      const cleaned = line.replace(/^\d+\.\s*/, '');
      return cleaned;
    })
    .filter(translation => translation.length > 0) // Remove empty translations
    .slice(0, expectedCount);
  
  console.log(`ЁЯФН Extracted ${translations.length} translations, expected ${expectedCount}`);
  
  // If we don't have enough translations, pad with empty strings
  while (translations.length < expectedCount) {
    translations.push('');
  }
  
  return translations;
};

// Post-process translations to fix common issues
const postProcessTranslations = (translations: string[], originalTexts: string[]): string[] => {
  const columnHeaders = ['Question', 'Option1', 'Option2', 'Option3', 'Option4', 'Correct ans', 'Answer', 'Explanation'];
  
  // Formal word replacements for better colloquial Hindi
  const formalWordReplacements: Record<string, string> = {
    'рдФрдкрдЪрд╛рд░рд┐рдХ': 'рдЬрд╝рд░реВрд░реА',
    'рдкреНрд░рд╕реНрддрд╛рд╡': 'рдпреЛрдЬрдирд╛',
    'рд╕реНрдкрд╖реНрдЯрддрд╛': 'рд╕рд╛рдлрд╝ рд╕рдордЭ',
    'рдкреНрд░рд╢рд┐рдХреНрд╖рдг': 'рд╕реАрдЦрдиреЗ рдХреА рдкрд╣рд▓',
    'рдкреНрд░рдХреНрд░рд┐рдпрд╛': 'рддрд░реАрдХрд╛',
    'рд╕рдВрджрд░реНрдн': 'рд╕рд╛рде',
    'рд╡рд┐рд╢реНрд▓реЗрд╖рдг': 'рдЬрд╛рдВрдЪ',
    'рд╕реБрд▓рдн': 'рдЖрд╕рд╛рди',
    'рд╕реНрдерд╛рдкрд┐рдд': 'рдордЬрд╝рдмреВрдд рдХрд░рдирд╛',
    'рд╕рд╣рднрд╛рдЧрд┐рддрд╛': 'рднрд╛рдЧреАрджрд╛рд░реА',
    'рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди': 'рд▓рд╛рдЧреВ рдХрд░рдирд╛',
    'рдкрд░рд┐рдгрд╛рдо': 'рдирддреАрдЬрд╛',
    'рдЙрджреНрджреЗрд╢реНрдп': 'рд▓рдХреНрд╖реНрдп',
    'рдкреНрд░рд╛рдкреНрддрд┐': 'рд╣рд╛рд╕рд┐рд▓ рдХрд░рдирд╛',
    'рд╡реНрдпрд╡рд╕реНрдерд╛': 'рдЗрдВрддрдЬрд╝рд╛рдо',
    'рдкреНрд░рдмрдВрдзрди': 'рд╕рдВрдЪрд╛рд▓рди',
    'рд╡рд┐рдХрд╛рд╕': 'рдмрдврд╝рд╛рд╡рд╛',
    'рд╕реБрдзрд╛рд░': 'рдмреЗрд╣рддрд░ рдмрдирд╛рдирд╛',
    'рдирд┐рд░реАрдХреНрд╖рдг': 'рдЬрд╛рдВрдЪ',
    'рдкрд░реАрдХреНрд╖рдг': 'рдЯреЗрд╕реНрдЯ'
  };
  
  return translations.map((translation, index) => {
    const originalText = originalTexts[index];
    
    // Fix column headers - remove serial numbers and ensure correct format
    if (columnHeaders.includes(originalText.trim())) {
      // Remove any serial numbers (both Arabic and Hindi numerals)
      let cleaned = translation.replace(/^[реж-реп0-9]+\.\s*/, '');
      
      // Ensure correct column header translations
      const headerMappings: Record<string, string> = {
        'Question': 'рдкреНрд░рд╢реНрди',
        'Option1': 'рд╡рд┐рдХрд▓реНрдк 1',
        'Option2': 'рд╡рд┐рдХрд▓реНрдк 2',
        'Option3': 'рд╡рд┐рдХрд▓реНрдк 3',
        'Option4': 'рд╡рд┐рдХрд▓реНрдк 4',
        'Correct ans': 'рд╕рд╣реА рдЙрддреНрддрд░',
        'Answer': 'рдЙрддреНрддрд░',
        'Explanation': 'рд╡реНрдпрд╛рдЦреНрдпрд╛'
      };
      
      const expectedTranslation = headerMappings[originalText.trim()];
      if (expectedTranslation && cleaned !== expectedTranslation) {
        console.log(`ЁЯФз Fixing column header: "${originalText}" -> "${cleaned}" -> "${expectedTranslation}"`);
        return expectedTranslation;
      }
      
      return cleaned;
    }
    
    // Replace formal words with colloquial alternatives (for non-column headers)
    let processedTranslation = translation;
    for (const [formalWord, colloquialWord] of Object.entries(formalWordReplacements)) {
      if (processedTranslation.includes(formalWord)) {
        processedTranslation = processedTranslation.replace(new RegExp(formalWord, 'g'), colloquialWord);
        console.log(`ЁЯФз Replacing formal word: "${formalWord}" -> "${colloquialWord}"`);
      }
    }
    
    return processedTranslation;
  });
};

export const getLanguageOptions = () => [
  { code: 'hi-IN' as const, name: 'Hindi', nativeName: 'рд╣рд┐рдВрджреА' },
  { code: 'mr-IN' as const, name: 'Marathi', nativeName: 'рдорд░рд╛рдареА' }
];

export const getToneOptions = () => [
  { value: 'formal' as const, label: 'Formal', description: 'Respectful and professional tone' },
  { value: 'neutral' as const, label: 'Neutral', description: 'Standard professional tone' },
  { value: 'conversational' as const, label: 'Conversational', description: 'Friendly and approachable tone' }
];

export const getDomainOptions = () => [
  { value: 'education' as const, label: 'Education', description: 'Educational content and materials' },
  { value: 'admin' as const, label: 'Administrative', description: 'Administrative documents and forms' },
  { value: 'marketing' as const, label: 'Marketing', description: 'Marketing materials and campaigns' },
  { value: 'technical' as const, label: 'Technical', description: 'Technical documentation and manuals' }
];

// Test function to verify custom prompts are working
export const testCustomPrompt = async (customPrompt: PromptTemplate): Promise<boolean> => {
  try {
    const testTexts = ['Hello', 'World', 'Test'];
    const testSettings: TranslationSettings = {
      target: 'hi-IN',
      tone: 'neutral',
      domain: 'education',
      quality: 'balanced'
    };
    
    console.log('ЁЯзк Testing custom prompt template:', customPrompt.name);
    
    const result = await translateBatch(testTexts, testSettings, [], customPrompt);
    
    console.log('тЬЕ Custom prompt test successful:', result);
    return result.length === testTexts.length;
  } catch (error) {
    console.error('тЭМ Custom prompt test failed:', error);
    return false;
  }
};
